# L2.1 - Intro to Relational Model p1

columns - attributes
each data instance called tuple or row

All values must be atomic

## Relational Schema and Instance

A1, A2, A3 - An are attributes in a schema
* **Each one is the name of a column in a schema**

R = (A1, A2, A3 - An) is a relational schema
	Example: instructor = (ID, name, dept_name, salary)
* **Basically that R is simply a blueprint, not any data is there**

Formally, given sets D1, D2 - D<sub>n</sub> a relation R is a subset of 
		D1 X D2 X D3 X ... X Dn
* **Each D is a Domain for that specific parameter - All possible values it can take**
* **The cartesian product is a set of all possible combinations of the given values**

Thus a relation is a set of n-tuples (a1, a2, ... , an) where each a<sub>i</sub> E D<sub>i</sub>
	Current values (relation instance) of a relation are specified by a table
	Element t of r is a tuple, represented by row in a table
* **Relation R is a subset of the cartesian product of all domains, all the tuples take up meaningful values**
## Keys
* Let K <= R (belongs to) where R is a set of attributes in the relation
### Types of Keys
#### Superkey
* K is a superkey of R if values for K are sufficient to identify a unique tuple of each possible relation r(R)
	* Example: {ID} and {ID, name} are both superkeys of instructor
**A Superkey is a set of one or more columns that can uniquely identify a row**

#### Candidate Key
* Superkey K is a **candidate key** if K is minimal
	* Example: {ID} is a candidate key of instructor
**If minimum number of columns are used to be able to uniquely identify every row, is known as a Candidate Key**

#### Primary Key
* One of the candidate keys is selected to be the primary key
	* Which one?
**Primary key is chosen from the set of candidate keys as a primary key by data engineers for operations in real world for identification**

#### Surrogate Key
* A surrogate key (or synthetic key) in a database is a unique identifier for either an entity in the modelled world or an object in the database
	* The surrogate key is not derived from application data, unlike a natural of business key which is derived from application data
**If there is no unique identifier inherently within the system like unique ID value, artificial or synthetic values are automatically generated by the database**

#### Simple Key
* A **Primary Key** is a column (or combination of columns) in a table that uniquely identifies each row.

#### Secondary Key
- A **Secondary Key** is any column (or combination of columns) that is used for **data retrieval** but is **not the primary key**.
- It is an additional means to access or query rows in a table.
- **Key Point**: Secondary keys are not required to be unique but help in indexing and querying data more efficiently.

#### Alternate Key
* An **Alternate Key** is any column (or combination of columns) that could have been chosen as the **Primary Key**, but wasn’t.

#### Compound Key
* Consists of more than one attribute to uniquely identify an entity occurrence
* Each attribute which makes up the key is a simple key in its own right


### Foreign Key Constraint
Value in one relation must appear in another
* Referencing relation

## Relational Query Languages

* Procedural programming requires that the programmer tell the computer what to do
	* How to get the output for the range of required inputs
	* programmer must know an appropriate algorithm
* Declarative programming requires a more descriptive style
	* Programmer must know what relationships hold between various entities



# L2.2 - Intro to Relational Model p2

## Basic properties of Relations
A relation is a set, hence
* Ordering of rows/tuples is inconsequential
* all rows/tuples must be distinct

### Selection:
𝜎<sub>cond1^cond2</sub>(r)
* cond1 -> condition 1; cond2 -> condition 2
* ^ -> and

## Set Operations
Same as math

## Joining two relations - Natural Join

Let r and s be relations on schemas R and S respectively. Then, the "natural join" of relations R and S is a relation on schema R U S obtained as follows:
* consider each pair of tuples t<sub>r</sub> from r and t<sub>s</sub> from s
* if t<sub>r</sub> and t<sub>s</sub> have same value on each of the attributes in R A S (intersection), add a tuple t to the result, where
	* t has the same value as t<sub>r</sub> on r
	* t has the same value as t<sub>s</sub> on s

![[Pasted image 20250122224920.png]]

## Aggregate Operators

Take all the rows in a column and give out a single value
Example:
* SUM
* AVG
* MAX
* MIN

## Parts of Relational Languages
* Each query is a table (or set of tables)
* Each query output is a table
* All data in the output table appears in one of the input tables
* Relational Algebra is not Turing complete

## Relational Algebra Operators
* **Selection operator (σ)**
	* Return rows of the input relation that satisfy the predicate
* Projection Operator (∏)
	* Output specified attributes from all rows of the input relation. Remove duplicate tuples from the output
* Cross Product(X)
* Union (U)
* Set Difference (-)
*   $\bowtie$ - Natural Join operator

# L2.3 - Intro to SQL p1

## Domain types in SQL
* char(n) - fixed length character string
* varchar(n) - variable length character strings, max n
* int - integer
* smallint(n) - small integer
* numeric(p, d) - Fixed point number, with user-specified precision of p digits, with d digits to the right of decimal point.
* real, double precision - floating point and double precision float
* float(n) - floating point number with user specified precision of at least n


## Creating Tables
```
create table r(A1D1, A2D2, - , AnDn,
				(integrity-constraint1),
				...
				(integrity-constraintk));
				
```
* r - name of relation
* Ai is an attribute name
* Di is data type of values in the domain of attribute Ai

Integrity constraint - primary key(ID) - declaration on an attribute automatically ensures not null


## Updating Tables (DDL Commands)
* Insert - inserts tuple
* Delete - removes all tuples from student relation
* Drop Table - drops a table entirely
* Alter
	* alter table r add A D
		* Where A is the name of the attribute to be added to relation r and D is the domain of A
		* All existing tuples assigned null
	* alter table r drop A
		* A is the name of an attribute of relation r
		* Dropping of attributes not supported by many databases

## Basic Query Structures
* Typical SQL Query as the form:
```
	select A1, A2, ... , An
	from r1, r2, ... , rm
	where P
```
* Ai represents an attribute from ri's
* ri represents a relation
* P is a predicate

### Select Clause
* select clause lists the attributed desired in the result of a query
	* corresponds to the projection operation of the relational algebra
* SQL names are case insensitive
* Duplicates are allowed in relations as well as in query results
* To eliminate duplicates, insert keyword **distinct** after select
```
select distinct A1
from r1
```
* To force all, insert **all** after select
```
select all a1
from r1
```
* Asterisk selects clause denotes all attributes
```
select *
from r1
```
* An attribute can be literal with no from clause
```
select '437'
#Result is a table with one column and a single row with value 437
select '437' as FOO
#returns column name with FOO with 437
```
* An attribute can be literal with from clause
```
select 'a'
from insturctor
#Result is a table with one column and N rows (Number of tuples in the table), each row with value 'a'
```
* select clause can contain arithmetic expressions involving the operations and the column can be renamed in the output too
```
select ID, name, salary/12 as monthly_clause
from instructor
```

### Where Clause
* The where clause specifies conditions that the result must satisfy
	* Corresponds to the selection predicate of the relational algebra

### From Clause
* Lists the relations involved in the query
	* Corresponds to the Cartesian product operation of the relational algebra
* Find the Cartesian product *instructor X teaches*
```
select *
from instructor, teaches
#Generates every possible instructor-teaches pair with all attributes from both relations
#For common attributes, attributes in the resulting table are renamed using the relation name eg instructor.ID
```

# L2.4 - Intro to SQL p2

## Cartesian Product
* Find the cartesian product *instructor* X *teaches*
```
select *
from instructor, teaches
```
*  Generates every possible instructor-teaches pair, with all attributes from both relations
* Cartesian product not very useful directly, but useful combined with where-clause condition (select operation in relational algebra)
Example:
```
# Example - 1: All instructors teaching a course
select name, course_id
from instructor, teaches
where instructor.ID = teached.ID

# Example - 2: All instructors in art department who have taught some course
select name, course_id
from instructor, teaches
where instructor.ID = teaches.ID and instructor.dept_name = 'Art'
```

## Rename AS Operation
* SQL allows renaming relations and attributes using the as clause:
		old_name as new_name
```
# Example: Find names of all instructors who have a higher salary than some instructor in Comp. Sci.

select distinct T.name
from instructor as T, instructor as S
where T.salary > S.salary and S.dept_name = 'Comp Sci'
```
* Keyboard *as* is optional and may be omitted
		instructor as T = instructor T

## String Operations

* SQL includes a string-matching operator for comparisons on character things. The operator ***like*** uses patterns that are described using two special character
	* % - matches any substring
	* __ - character matches any character

```
# Find Instructor whose name includes substring "dar"
select name
from instructor
where name like "%dar%"

# Match the string "100%"
like '100%' escape '\'
#Use backlash as the escape character
```

* Patterns are case sensitive
* Pattern matching examples
	* Intro% - matches any string beginning with Intro
	* %Comp% - matches any string containing Comp as substring
	* '_ _ _' - matches any string of exactly three characters
	* '_ _ _ %' - matches any string of at least three characters
* SQL supports a variety of string operations such as 
	* Concatenation "||"
	* upper<->lower
	* string length, extract substring, etc

## Ordering the Display of Tuples

```
# list in alphabetic order the names of all instructors
selct distinct name
from instructor
order by name

# can specify asc and desc for ascending and descending, ascending is default
order by name desc

# Can sort on multiple attributes
order by dept_name, name
```

## Select the number of Tuples in Output
* **Select Top** clause is used to specify the number of records to return
* useful on large tables with thousands of records. Returning a large number of records can impact performance
```
select top 10 distinct name
frrom instructor
```
* Not all DBMS support the SELECT TOP clause
	* SQL Server, MS Access support
	* MySQL  -> limit clause
	* oracle uses **fetch first n rows only and rownum**
```
	select distinct name
	from instructor
	order by name
	fetch first 10 rows only
```

## Where Clause Predicates
* **between** comparison operator
```
# find names of all instructors with salary between 90k and 100k
select name
from instructor
where salary between 90000 and 100000
```
* Tuple comparison
```
select name, course_id
from teaches, instructor
where (instructor.ID, dept_name) = (teaches.ID, Biology)
```

## In Operator
* The **in** operator allows you to specify multiple values in a **where** clause, shorthand for multiple or conditions
```
select name
from instructor
where dept_name in ("Comp Sci.", "Biology")
```

# Duplicates
* In relation with duplicates, SQL can define how many copies of tuples appear in the result
* Multiset in algebra means set where the same object can occur multiple times
* Multiset versions of some of the relational algebra operators - given multiset relations r1 and r2
	* **σ<sub>theta</sub> (r1):** Is there are c1 copes of tuple t1 inside r1, and t1 satisfies selections σ<sub>theta</sub>, then there are c1 copes of t1 in σ<sub>theta</sub> (r1)
	* **∏<sub>a</sub>(r):** For each copy of tuple t1 in r1, there is a copy of tuple ∏<sub>a</sub>(t1) in ∏<sub>a</sub>(r1) where ∏<sub>a</sub>(t1) denotes the projection of the single tuple t1
	* **r1 x r2:** If there are c1 copies of the tuple t1 in r1 and c2 copies of tuple t2 in r2, there are c1 x c2 copies of the tuple t1.t2 in r1 x r2

```
r1 = {(1,a), (2,a)}
r1 = {(2), (3), (3)}

∏(r1) = {(a),(a)} while ∏(r1) x r2 would be

{(a,2), (a,2), (a,3), (a,3), (a,3), (a,3)}
```

```
# SQL Duplicate semantics
select A1, A2, ... , An
from r1, r2, ... , rm
where P
```
* The above is equivalent to the multiset relational algebra version of the expression:
			∏<sub>A1, A2, ... , An</sub>(σ<sub>P</sub> (r1 x r2 x ... x rm))


# L2.5 - Intro to SQL p3
